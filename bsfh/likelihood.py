import time, sys, os
import numpy as np
from scipy.linalg import LinAlgError

class LikelihoodFunction(object):
    
    def __init__(self, obs=None, model=None, lnspec=True):
        self.obs = obs
        self.model = model
        self.lnspec = lnspec
        
    def lnlike_spec(self, spec_mu, obs=None, gp=None,
                    spec_noise_fractional=False, **extras):
        """Calculate the likelihood of the spectroscopic data given
        the spectroscopic model.  Allows for the use of a gaussian
        process covariance matrix for multiplicative residuals.

        :param spec_mu:
            The mean model spectrum, in linear or logarithmic units, including
            e.g. calibration and sky emission.
            
        :param obs: (optional)
            A dictionary of the observational data, including the keys
              *``spectrum`` a numpy array of the observed spectrum, in
               linear or logarithmic units (same as ``spec_mu``).
              *``unc`` the uncertainty of same length as ``spectrum``
              *``mask`` optional boolean array of same length as
               ``spectrum``
              *``wavelength`` if using a GP, the metric that is used
               in the kernel generation, of same length as
               ``spectrum`` and typically giving the wavelength array.

            If not supplied then the obs dictionary given at
            initialization will be used.

        :param gp: (optional)
            A Gaussian process object with the methods `compute` and
            `lnlikelihood`.  If gp is supplied, the `wavelength` entry
            in the obs dictionary must exist

        :param spec_noise_fractional: (optional)
            If true then the amplitude of the GP is taken to be a
            fraction of the model flux.
             
        :returns lnlikelhood:
            The natural logarithm of the likelihood of the data given
            the mean model spectrum.
        """
        
        if obs is None:
            obs = self.obs
        if obs['spectrum'] is None:
            return 0.0
    
        mask = obs.get('mask', np.ones( len(obs['spectrum']), dtype= bool))
        delta = (obs['spectrum'] - spec_mu)[mask]
        if gp is not None:
            if spec_noise_fractional:
                flux = spec_mu[mask]
            else:
                flux = 1
            try:
                gp.compute(obs['wavelength'][mask], obs['unc'][mask], flux=flux)
                return gp.lnlikelihood(delta)
            except(LinAlgError):
                return np.nan_to_num(-np.inf)
            
        var = obs['unc'][mask]**2
        lnp = -0.5*( (delta**2/var).sum() +
                     np.log(2*np.pi*var).sum() )
        return lnp
        
    def lnlike_phot_mixture(self, phot_mu, p_outlier, sigma_outlier,
                            **kwargs):
        """Wrapper on lnlike_phot that implements a mixture model for the outliers
        """
        mask = obs.get('phot_mask', np.ones( len(obs['maggies']), dtype= bool))
        nobs = mask.sum()
        #need to define delta
        delta = (obs['maggies'] - phot_mu)[mask]
        lnlike_inlier = (self.lnlike_phot(phot_mu, **kwargs) +
                         nobs * np.log(1-p_outlier))
        if kwargs.get('phot_noise_fractional', True):
            var_outlier = (phot_mu[mask] * sigma_outlier)**2
        else:
            var_outlier = np.zeros(nobs) + sigma_outlier**2
        lnlike_outlier =  -0.5*( (delta**2/var_outlier).sum() +
                                 np.log(2 * np.pi * var_outlier).sum() )
        lnlike_outlier += nobs * np.log(p_outlier)
        return lnlike_inlier + lnlike_outlier
        
    def lnlike_phot(self, phot_mu, obs=None, gp=None,
                    phot_noise_fractional=True, **extras):
        """Calculate the likelihood of the photometric data given the
        spectroscopic model.  Allows for the use of a gaussian process
        covariance matrix.
        
        :param phot_mu:
            The mean model sed, in linear flux units (i.e. maggies),
            including e.g. calibration and sky emission and nebular
            emission.
            
        :param obs: (optional)
            A dictionary of the observational data, including the keys
              *``maggies`` a numpy array of the observed SED, in
               linear flux units
              *``maggies_unc`` the uncertainty of same length as
               ``maggies``
              *``phot_mask`` optional boolean array of same length as
               ``maggies``
              *``filters`` optional list of sedpy.observate.Filter
               objects, necessary if using fixed filter groups with
               different gp amplitudes for each group.
           If not supplied then the obs dictionary given at
           initialization will be used.  

        :param gp: (optional)
            A Gaussian process object with the methods ``compute()`` and
            ``lnlikelihood()``.

        :param fractional:
            Treat the GP amplitudes as additional *fractional*
            uncertainties, i.e., multiplicative uncertainties.
            
        :returns lnlikelhood:
            The natural logarithm of the likelihood of the data given
            the mean model spectrum.
        """

        if obs is None:
            obs = self.obs
        if obs['maggies'] is None:
            return 0.0
    
        mask = obs.get('phot_mask', np.ones( len(obs['maggies']), dtype= bool))
        delta = (obs['maggies'] - phot_mu)[mask]
        if gp is not None:
            if phot_noise_fractional:
                flux = phot_mu[mask]
            else:
                flux = 1
            gp.compute(wave=1, sigma=obs['maggies_unc'][mask], flux=flux)
            return gp.lnlikelihood(delta)
        
        var = (obs['maggies_unc'][mask])**2
        lnp = -0.5*( (delta**2/var).sum() +
                     np.log(2*np.pi*var).sum() )
        return lnp
    
    def ln_prior_prob(self, theta, model=None):
        if model is None:
            model = self.model
        return model.prior_product(theta)

    def lnpostfn(self, theta, model=None, obs=None,
               sps=None, gp=None, **extras):
        """A specific implementation of a posterior probability
        function, as an example.
        """
        if model is None:
            model = self.model
        if obs is None:
            obs = self.obs
            
        # Get the prior
        lnp_prior= self.ln_prior_prob(theta)
        if np.isfinite(lnp_prior):
            # Get the mean model and GP Kernel
            spec, phot, x = model.mean_model(theta, sps = sps)
            log_mu = np.log(spec) + mod.calibration(theta)
            s, a, l = (mod.params['gp_jitter'], mod.params['gp_amplitude'],
                       mod.params['gp_length'])
            gp.kernel[:] = np.log(np.array([s[0],a[0]**2,l[0]**2]))
            # Get the likelihoods
            lnp_spec = self.lnlike_spec_log(np.exp(log_mu), obs=obs, gp=gp)
            lnp_phot = self.lnlike_phot(phot, obs=obs, gp=None)
            # Return the sum
            return lnp_prior + lnp_phot + lnp_spec
        else:
            return -np.infty
